clc;
clear;
close all;

FileName = 'SEFDMtestlist.txt';

% The value of setting can differs from allowed
% Settings for sweep
    Set1 = [...
        {'NrChannel.Type = 2; NrChannel.FadingType = 1; NrChannel.MaxDopShift = 5'}, ...
        {'NrChannel.Type = 2; NrChannel.FadingType = 2; NrChannel.MaxDopShift = 70'}, ...
        {'NrChannel.Type = 2; NrChannel.FadingType = 3; NrChannel.MaxDopShift = 300'}];
    Set2 = [...
        {'Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.9'}, ...
        {'Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.8'}, ...
        {'Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.7'}, ...
        {'Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.9'}, ...
        {'Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.8'}, ...
        {'Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.7'}];
    Set3 = [...
        {'SchSource.McsIndex = 0'}, ...
        {'SchSource.McsIndex = 1'}, ...
        {'SchSource.McsIndex = 2'}, ...
        {'SchSource.McsIndex = 3'}, ...
        {'SchSource.McsIndex = 4'}, ...
        {'SchSource.McsIndex = 5'}, ...
        {'SchSource.McsIndex = 6'}, ...
        {'SchSource.McsIndex = 7'}, ...
        {'SchSource.McsIndex = 8'}, ...
        {'SchSource.McsIndex = 9'}, ...
        {'SchSource.McsIndex = 10'}, ...
        {'SchSource.McsIndex = 11'}, ...
        {'SchSource.McsIndex = 12'}, ...
        {'SchSource.McsIndex = 13'}, ...
        {'SchSource.McsIndex = 14'}, ...
        {'SchSource.McsIndex = 15'}, ...
        {'SchSource.McsIndex = 16'}, ...
        {'SchSource.McsIndex = 17'}];
    
% Fixed settings
    FixedSet = ['Common.SaveDirName = SEFDMfadingChans; ', ...
        'BER.MinBER = 10^-3; Common.NumWorkers = 4; '];
    FlushStr = 'End of Params\n';
        
% All sets need to be added as input arguments
    CombArr = allcomb(Set1, Set2, Set3);

% Keys and maps of introduced sweep for SaveFileName
KeySaveFileName = [...
    "NrChannel.Type = 2; NrChannel.FadingType = 1; NrChannel.MaxDopShift = 5", ...
    "NrChannel.Type = 2; NrChannel.FadingType = 2; NrChannel.MaxDopShift = 70", ...
    "NrChannel.Type = 2; NrChannel.FadingType = 3; NrChannel.MaxDopShift = 300", ...
    ...
    "Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.9", ...
    "Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.8", ...
    "Sig.Type = SEFDM; SEFDM.FormType = 2; SEFDM.AlphaTime = 0.7", ...
    "Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.9", ...
    "Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.8", ...
    "Sig.Type = SEFDM; SEFDM.FormType = 3; SEFDM.AlphaFreq = 0.7", ...
    ...
    "SchSource.McsIndex = 0", ...
    "SchSource.McsIndex = 1", ...
    "SchSource.McsIndex = 2", ...
    "SchSource.McsIndex = 3", ...
    "SchSource.McsIndex = 4", ...
    "SchSource.McsIndex = 5", ...
    "SchSource.McsIndex = 6", ...
    "SchSource.McsIndex = 7", ...
    "SchSource.McsIndex = 8", ...
    "SchSource.McsIndex = 9", ...
    "SchSource.McsIndex = 10", ...
    "SchSource.McsIndex = 11", ...
    "SchSource.McsIndex = 12", ...
    "SchSource.McsIndex = 13", ...
    "SchSource.McsIndex = 14", ...
    "SchSource.McsIndex = 15", ...
    "SchSource.McsIndex = 16", ...
    "SchSource.McsIndex = 17", ...
    ...
    ];
MapSaveFileName = [...
    "EPA5", ...
    "EVA70", ...
    "ETU300", ...
    ...
    "TOFDM0_9", ...
    "TOFDM0_8", ...
    "TOFDM0_7", ...
    "SEFDM0_9", ...
    "SEFDM0_8", ...
    "SEFDM0_7", ...
    ...
    "MCS0", ...
    "MCS1", ...
    "MCS2", ...
    "MCS3", ...
    "MCS4", ...
    "MCS5", ...
    "MCS6", ...
    "MCS7", ...
    "MCS8", ...
    "MCS9", ...
    "MCS10", ...
    "MCS11", ...
    "MCS12", ...
    "MCS13", ...
    "MCS14", ...
    "MCS15", ...
    "MCS16", ...
    "MCS17", ...
    ...
    ];

% Processing
Fid = fopen(FileName, 'wt');
for k = 1 : size(CombArr, 1)
    Str = FixedSet;
    SaveFileName = 'Common.SaveFileName = ';
    for n = 1 : size(CombArr, 2)
        Str = [Str, CombArr{k, n}, '; ']; %#ok<*AGROW>
        
        Idx = find(KeySaveFileName == CombArr{k, n});
        if ~isempty(Idx)
            SaveFileName = [SaveFileName, convertStringsToChars(MapSaveFileName(Idx))];
        end
    end
    SaveFileName = [SaveFileName, '; '];
    Str = [SaveFileName, Str, FlushStr];
    fprintf(Fid, Str);
end
fclose(Fid);
    
function A = allcomb(varargin)
% ALLCOMB - All combinations
%    B = ALLCOMB(A1,A2,A3,...,AN) returns all combinations of the elements
%    in the arrays A1, A2, ..., and AN. B is P-by-N matrix where P is the product
%    of the number of elements of the N inputs. 
%    This functionality is also known as the Cartesian Product. The
%    arguments can be numerical and/or characters, or they can be cell arrays.
%
%    Examples:
%       allcomb([1 3 5],[-3 8],[0 1]) % numerical input:
%       % -> [ 1  -3   0
%       %      1  -3   1
%       %      1   8   0
%       %        ...
%       %      5  -3   1
%       %      5   8   1 ] ; % a 12-by-3 array
%
%       allcomb('abc','XY') % character arrays
%       % -> [ aX ; aY ; bX ; bY ; cX ; cY] % a 6-by-2 character array
%
%       allcomb('xy',[65 66]) % a combination -> character output
%       % -> ['xA' ; 'xB' ; 'yA' ; 'yB'] % a 4-by-2 character array
%
%       allcomb({'hello','Bye'},{'Joe', 10:12},{99999 []}) % all cell arrays
%       % -> {  'hello'  'Joe'        [99999]
%       %       'hello'  'Joe'             []
%       %       'hello'  [1x3 double] [99999]
%       %       'hello'  [1x3 double]      []
%       %       'Bye'    'Joe'        [99999]
%       %       'Bye'    'Joe'             []
%       %       'Bye'    [1x3 double] [99999]
%       %       'Bye'    [1x3 double]      [] } ; % a 8-by-3 cell array
%
%    ALLCOMB(..., 'matlab') causes the first column to change fastest which
%    is consistent with matlab indexing. Example: 
%      allcomb(1:2,3:4,5:6,'matlab') 
%      % -> [ 1 3 5 ; 1 4 5 ; 1 3 6 ; ... ; 2 4 6 ]
%
%    If one of the N arguments is empty, ALLCOMB returns a 0-by-N empty array.
%    
%    See also NCHOOSEK, PERMS, NDGRID
%         and NCHOOSE, COMBN, KTHCOMBN (Matlab Central FEX)
% Tested in Matlab R2015a and up
% version 4.2 (apr 2018)
% (c) Jos van der Geest
% email: samelinoa@gmail.com
% History
% 1.1 (feb 2006), removed minor bug when entering empty cell arrays;
%     added option to let the first input run fastest (suggestion by JD)
% 1.2 (jan 2010), using ii as an index on the left-hand for the multiple
%     output by NDGRID. Thanks to Jan Simon, for showing this little trick
% 2.0 (dec 2010). Bruno Luong convinced me that an empty input should
% return an empty output.
% 2.1 (feb 2011). A cell as input argument caused the check on the last
%      argument (specifying the order) to crash.
% 2.2 (jan 2012). removed a superfluous line of code (ischar(..))
% 3.0 (may 2012) removed check for doubles so character arrays are accepted
% 4.0 (feb 2014) added support for cell arrays
% 4.1 (feb 2016) fixed error for cell array input with last argument being
%     'matlab'. Thanks to Richard for pointing this out.
% 4.2 (apr 2018) fixed some grammar mistakes in the help and comments
narginchk(1,Inf) ;
NC = nargin ;
% check if we should flip the order
if ischar(varargin{end}) && (strcmpi(varargin{end}, 'matlab') || strcmpi(varargin{end}, 'john'))
    % based on a suggestion by JD on the FEX
    NC = NC-1 ;
    ii = 1:NC ; % now first argument will change fastest
else
    % default: enter arguments backwards, so last one (AN) is changing fastest
    ii = NC:-1:1 ;
end
args = varargin(1:NC) ;
if any(cellfun('isempty', args)) % check for empty inputs
    warning('ALLCOMB:EmptyInput','One of more empty inputs result in an empty output.') ;
    A = zeros(0, NC) ;
elseif NC == 0 % no inputs
    A = zeros(0,0) ; 
elseif NC == 1 % a single input, nothing to combine
    A = args{1}(:) ; 
else
    isCellInput = cellfun(@iscell, args) ;
    if any(isCellInput)
        if ~all(isCellInput)
            error('ALLCOMB:InvalidCellInput', ...
                'For cell input, all arguments should be cell arrays.') ;
        end
        % for cell input, we use to indices to get all combinations
        ix = cellfun(@(c) 1:numel(c), args, 'un', 0) ;
        
        % flip using ii if last column is changing fastest
        [ix{ii}] = ndgrid(ix{ii}) ;
        
        A = cell(numel(ix{1}), NC) ; % pre-allocate the output
        for k = 1:NC
            % combine
            A(:,k) = reshape(args{k}(ix{k}), [], 1) ;
        end
    else
        % non-cell input, assuming all numerical values or strings
        % flip using ii if last column is changing fastest
        [A{ii}] = ndgrid(args{ii}) ;
        % concatenate
        A = reshape(cat(NC+1,A{:}), [], NC) ;
    end
end
end

